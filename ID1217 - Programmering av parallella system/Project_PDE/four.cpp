#include <iostream>#include <cstdlib>#include <string>#include <omp.h>#include <fstream>#include <iomanip>using namespace std;void jacobi(int);void compute(int);void interpolation(int);int gridSize, numIters, numWorkers, i, j;double start, stop;double **one;double **two;int maxSize;int main(int argc, char *argv[]) {    if (argc != 4) {        cerr << "Usage for program '" << argv[0] << "': gridSize numIters numWorkers" << endl;        return -1;    } else {        gridSize = atoi(argv[1]);        numIters = atoi(argv[2]);        numWorkers = atoi(argv[3]);    }    // V level 4 times    maxSize = 4 * (2 * gridSize + 1) + 4;    // Create 2D arrays    one = (double **) malloc(maxSize * sizeof(double));    two = (double **) malloc(maxSize * sizeof(double));    // Init array borders to 1, and inner values to 0    for (i = 0; i < maxSize; i++) {        one[i] = (double *) malloc(maxSize * sizeof(double));        two[i] = (double *) malloc(maxSize * sizeof(double));        for (j = 0; j < maxSize; j++) {            if (i == 0 || j == 0 || i == maxSize - 1 || j == maxSize - 1) {                one[i][j] = 1.0;                two[i][j] = 1.0;            } else {                one[i][j] = 0.0;                two[i][j] = 0.0;            }        }    }    // Set number of threads for OpenMP to run with.    omp_set_num_threads(numWorkers);    // All parts below need to run in Sequential order.    // Their inner workings can run in parallel though, which is handeled in each specific function/method.    start = omp_get_wtime();    jacobi(4);    compute(2);    jacobi(4);    compute(4);    jacobi(4);    compute(8);    // "Use exactly four iterations on each of the finer grids,    // and use the command-line argument numIters (see below) for the number of iterations on the coarsest (smallest) grid."    // This is now the coarsest, so we go numIters jacobi.    jacobi(numIters);    interpolation(8);    jacobi(4);    interpolation(4);    jacobi(4);    interpolation(2);    jacobi(4);    stop = omp_get_wtime();    // Calculate max offset.    // I know that it's actually the 1 or 4 values in the center, but w/e    double maxOffset = 1.0;    for (i = 1; i < maxSize - 1; i++) {        for (j = 1; j < maxSize - 1; j++) {            if (maxOffset > one[i][j]) {                maxOffset = one[i][j];            }        }    }    // Print results, as according to project description.    cout << "--- Program Done ---" << endl;    cout << "Program line arguments: " << argv[0] << " " << atoi(argv[1]) << " " << atoi(argv[2]) << " "         << atoi(argv[3]) << endl;    cout << "Execution time for computes: " << stop - start << " seconds." << endl;    cout << "Lowest value found was: " << fixed << setprecision(12) << maxOffset << " which gives an error of: "         << fixed << setprecision(12) << 1.0 - maxOffset << endl;    cout << "Data printed to filedata.out" << endl;    ofstream file;    file.open("filedata.out");    for (int i = 0; i < maxSize; i++) {        for (int j = 0; j < maxSize; j++) {            file << fixed << setprecision(12) << one[i][j] << " ";        }        file << endl;    }    file.close();    return 0;}void jacobi(int iterations) {    for (int iters = 0; iters < iterations; iters++) {        #pragma omp parallel for private(j) schedule(static)        for (i = 1; i < maxSize - 1; i++) {            for (j = 1; j < maxSize - 1; j++) {                two[i][j] = (one[i - 1][j] + one[i + 1][j] + one[i][j - 1] + one[i][j + 1]) * 0.25;            }        }        double **temp = one;        one = two;        two = temp;    }    return;}void compute(int increase) {    // 2 to maxSize -2 cause we don't want a coarse point direct neighbour to the border. Will cause segmentation fault.    #pragma omp parallel for private(j) schedule(static)    for (i = 2; i < maxSize - 2; i = i + increase) {        for (j = 2; j < maxSize - 2; j = j + increase) {            two[i][j] = one[i][j] * 0.5 + (one[i - 1][j] + one[i + 1][j] + one[i][j - 1] + one[i][j + 1]) * 0.125;        }    }    double **temp = one;    one = two;    two = temp;    return;}void interpolation(int increase) {    /*     * 1/4 1/2 1/4     * 1/2  1  1/2     * 1/4 1/2 1/4     */    // 2 to maxSize -2 cause we don't place any coarse points direct neighbour to the border. Will cause segmentation fault.    // Special case since we might edit same Fine grid points.    if (increase == 2) {        for (i = 2; i < maxSize - 2; i = i + increase) {            for (j = 2; j < maxSize - 2; j = j + increase) {                // 1/2 points.                two[i - 1][j] = (one[i - 2][j] + one[i][j]) * 0.5;                two[i + 1][j] = (one[i + 2][j] + one[i][j]) * 0.5;                two[i][j - 1] = (one[i][j - 2] + one[i][j]) * 0.5;                two[i][j + 1] = (one[i][j + 2] + one[i][j]) * 0.5;                // 1/4 corners.                two[i - 1][j - 1] = (one[i - 1][j - 2] + one[i - 1][j]) * 0.5;                two[i - 1][j + 1] = (one[i - 1][j + 2] + one[i - 1][j]) * 0.5;                two[i + 1][j - 1] = (one[i + 1][j - 2] + one[i + 1][j]) * 0.5;                two[i + 1][j + 1] = (one[i + 1][j + 2] + one[i + 1][j]) * 0.5;            }        }    } else {        #pragma omp parallel for private(j) schedule(static)        for (i = 2; i < maxSize - 2; i = i + increase) {            for (j = 2; j < maxSize - 2; j = j + increase) {                // 1/2 points.                two[i - 1][j] = (one[i - 2][j] + one[i][j]) * 0.5;                two[i + 1][j] = (one[i + 2][j] + one[i][j]) * 0.5;                two[i][j - 1] = (one[i][j - 2] + one[i][j]) * 0.5;                two[i][j + 1] = (one[i][j + 2] + one[i][j]) * 0.5;                // 1/4 corners.                two[i - 1][j - 1] = (one[i - 1][j - 2] + one[i - 1][j]) * 0.5;                two[i - 1][j + 1] = (one[i - 1][j + 2] + one[i - 1][j]) * 0.5;                two[i + 1][j - 1] = (one[i + 1][j - 2] + one[i + 1][j]) * 0.5;                two[i + 1][j + 1] = (one[i + 1][j + 2] + one[i + 1][j]) * 0.5;            }        }    }    double **temp = one;    one = two;    two = temp;    return;}